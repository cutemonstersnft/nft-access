{"ast":null,"code":"import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { TOKEN_PROGRAM_ID } from './../constants.mjs';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError } from './../errors.mjs';\n/** Token account state as stored by the program */\n\nexport var AccountState;\n\n(function (AccountState) {\n  AccountState[AccountState[\"Uninitialized\"] = 0] = \"Uninitialized\";\n  AccountState[AccountState[\"Initialized\"] = 1] = \"Initialized\";\n  AccountState[AccountState[\"Frozen\"] = 2] = \"Frozen\";\n})(AccountState || (AccountState = {}));\n/** Buffer layout for de/serializing a token account */\n\n\nexport const AccountLayout = struct([publicKey('mint'), publicKey('owner'), u64('amount'), u32('delegateOption'), publicKey('delegate'), u8('state'), u32('isNativeOption'), u64('isNative'), u64('delegatedAmount'), u32('closeAuthorityOption'), publicKey('closeAuthority')]);\n/** Byte length of a token account */\n\nexport const ACCOUNT_SIZE = AccountLayout.span;\n/**\n * Retrieve information about a token account\n *\n * @param connection Connection to use\n * @param address    Token account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token account information\n */\n\nexport async function getAccount(connection, address, commitment) {\n  let programId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TOKEN_PROGRAM_ID;\n  const info = await connection.getAccountInfo(address, commitment);\n  if (!info) throw new TokenAccountNotFoundError();\n  if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n  if (info.data.length != ACCOUNT_SIZE) throw new TokenInvalidAccountSizeError();\n  const rawAccount = AccountLayout.decode(info.data);\n  return {\n    address,\n    mint: rawAccount.mint,\n    owner: rawAccount.owner,\n    amount: rawAccount.amount,\n    delegate: rawAccount.delegateOption ? rawAccount.delegate : null,\n    delegatedAmount: rawAccount.delegatedAmount,\n    isInitialized: rawAccount.state !== AccountState.Uninitialized,\n    isFrozen: rawAccount.state === AccountState.Frozen,\n    isNative: !!rawAccount.isNativeOption,\n    rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,\n    closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null\n  };\n}\n/** Get the minimum lamport balance for a token account to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\n\nexport async function getMinimumBalanceForRentExemptAccount(connection, commitment) {\n  return await connection.getMinimumBalanceForRentExemption(ACCOUNT_SIZE, commitment);\n}","map":{"version":3,"mappings":"AAAA,SAASA,MAAT,EAAiBC,GAAjB,EAAsBC,EAAtB,QAAgC,uBAAhC;AACA,SAASC,SAAT,EAAoBC,GAApB,QAA+B,6BAA/B;AAEA,SAASC,gBAAT,QAAiC,oBAAjC;AACA,SAASC,yBAAT,EAAoCC,6BAApC,EAAmEC,4BAAnE,QAAuG,iBAAvG;AA+BA;;AACA,WAAYC,YAAZ;;AAAA,WAAYA,YAAZ,EAAwB;EACpBA;EACAA;EACAA;AACH,CAJD,EAAYA,YAAY,KAAZA,YAAY,MAAxB;AAqBA;;;AACA,OAAO,MAAMC,aAAa,GAAGV,MAAM,CAAa,CAC5CG,SAAS,CAAC,MAAD,CADmC,EAE5CA,SAAS,CAAC,OAAD,CAFmC,EAG5CC,GAAG,CAAC,QAAD,CAHyC,EAI5CH,GAAG,CAAC,gBAAD,CAJyC,EAK5CE,SAAS,CAAC,UAAD,CALmC,EAM5CD,EAAE,CAAC,OAAD,CAN0C,EAO5CD,GAAG,CAAC,gBAAD,CAPyC,EAQ5CG,GAAG,CAAC,UAAD,CARyC,EAS5CA,GAAG,CAAC,iBAAD,CATyC,EAU5CH,GAAG,CAAC,sBAAD,CAVyC,EAW5CE,SAAS,CAAC,gBAAD,CAXmC,CAAb,CAA5B;AAcP;;AACA,OAAO,MAAMQ,YAAY,GAAGD,aAAa,CAACE,IAAnC;AAEP;;;;;;;;;;;AAUA,OAAO,eAAeC,UAAf,CACHC,UADG,EAEHC,OAFG,EAGHC,UAHG,EAIyB;EAAA,IAA5BC,SAA4B,uEAAhBZ,gBAAgB;EAE5B,MAAMa,IAAI,GAAG,MAAMJ,UAAU,CAACK,cAAX,CAA0BJ,OAA1B,EAAmCC,UAAnC,CAAnB;EACA,IAAI,CAACE,IAAL,EAAW,MAAM,IAAIZ,yBAAJ,EAAN;EACX,IAAI,CAACY,IAAI,CAACE,KAAL,CAAWC,MAAX,CAAkBJ,SAAlB,CAAL,EAAmC,MAAM,IAAIV,6BAAJ,EAAN;EACnC,IAAIW,IAAI,CAACI,IAAL,CAAUC,MAAV,IAAoBZ,YAAxB,EAAsC,MAAM,IAAIH,4BAAJ,EAAN;EAEtC,MAAMgB,UAAU,GAAGd,aAAa,CAACe,MAAd,CAAqBP,IAAI,CAACI,IAA1B,CAAnB;EAEA,OAAO;IACHP,OADG;IAEHW,IAAI,EAAEF,UAAU,CAACE,IAFd;IAGHN,KAAK,EAAEI,UAAU,CAACJ,KAHf;IAIHO,MAAM,EAAEH,UAAU,CAACG,MAJhB;IAKHC,QAAQ,EAAEJ,UAAU,CAACK,cAAX,GAA4BL,UAAU,CAACI,QAAvC,GAAkD,IALzD;IAMHE,eAAe,EAAEN,UAAU,CAACM,eANzB;IAOHC,aAAa,EAAEP,UAAU,CAACQ,KAAX,KAAqBvB,YAAY,CAACwB,aAP9C;IAQHC,QAAQ,EAAEV,UAAU,CAACQ,KAAX,KAAqBvB,YAAY,CAAC0B,MARzC;IASHC,QAAQ,EAAE,CAAC,CAACZ,UAAU,CAACa,cATpB;IAUHC,iBAAiB,EAAEd,UAAU,CAACa,cAAX,GAA4Bb,UAAU,CAACY,QAAvC,GAAkD,IAVlE;IAWHG,cAAc,EAAEf,UAAU,CAACgB,oBAAX,GAAkChB,UAAU,CAACe,cAA7C,GAA8D;EAX3E,CAAP;AAaH;AAED;;;;;;;;AAOA,OAAO,eAAeE,qCAAf,CACH3B,UADG,EAEHE,UAFG,EAEoB;EAEvB,OAAO,MAAMF,UAAU,CAAC4B,iCAAX,CAA6C/B,YAA7C,EAA2DK,UAA3D,CAAb;AACH","names":["struct","u32","u8","publicKey","u64","TOKEN_PROGRAM_ID","TokenAccountNotFoundError","TokenInvalidAccountOwnerError","TokenInvalidAccountSizeError","AccountState","AccountLayout","ACCOUNT_SIZE","span","getAccount","connection","address","commitment","programId","info","getAccountInfo","owner","equals","data","length","rawAccount","decode","mint","amount","delegate","delegateOption","delegatedAmount","isInitialized","state","Uninitialized","isFrozen","Frozen","isNative","isNativeOption","rentExemptReserve","closeAuthority","closeAuthorityOption","getMinimumBalanceForRentExemptAccount","getMinimumBalanceForRentExemption"],"sources":["/Users/khairulamirinrohmat/nft-access/bedrock-nft-access/node_modules/@solana/spl-token/src/state/account.ts"],"sourcesContent":["import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { Commitment, Connection, PublicKey } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError } from '../errors';\n\n/** Information about a token account */\nexport interface Account {\n    /** Address of the account */\n    address: PublicKey;\n    /** Mint associated with the account */\n    mint: PublicKey;\n    /** Owner of the account */\n    owner: PublicKey;\n    /** Number of tokens the account holds */\n    amount: bigint;\n    /** Authority that can transfer tokens from the account */\n    delegate: PublicKey | null;\n    /** Number of tokens the delegate is authorized to transfer */\n    delegatedAmount: bigint;\n    /** True if the account is initialized */\n    isInitialized: boolean;\n    /** True if the account is frozen */\n    isFrozen: boolean;\n    /** True if the account is a native token account */\n    isNative: boolean;\n    /**\n     * If the account is a native token account, it must be rent-exempt. The rent-exempt reserve is the amount that must\n     * remain in the balance until the account is closed.\n     */\n    rentExemptReserve: bigint | null;\n    /** Optional authority to close the account */\n    closeAuthority: PublicKey | null;\n}\n\n/** Token account state as stored by the program */\nexport enum AccountState {\n    Uninitialized = 0,\n    Initialized = 1,\n    Frozen = 2,\n}\n\n/** Token account as stored by the program */\nexport interface RawAccount {\n    mint: PublicKey;\n    owner: PublicKey;\n    amount: bigint;\n    delegateOption: 1 | 0;\n    delegate: PublicKey;\n    state: AccountState;\n    isNativeOption: 1 | 0;\n    isNative: bigint;\n    delegatedAmount: bigint;\n    closeAuthorityOption: 1 | 0;\n    closeAuthority: PublicKey;\n}\n\n/** Buffer layout for de/serializing a token account */\nexport const AccountLayout = struct<RawAccount>([\n    publicKey('mint'),\n    publicKey('owner'),\n    u64('amount'),\n    u32('delegateOption'),\n    publicKey('delegate'),\n    u8('state'),\n    u32('isNativeOption'),\n    u64('isNative'),\n    u64('delegatedAmount'),\n    u32('closeAuthorityOption'),\n    publicKey('closeAuthority'),\n]);\n\n/** Byte length of a token account */\nexport const ACCOUNT_SIZE = AccountLayout.span;\n\n/**\n * Retrieve information about a token account\n *\n * @param connection Connection to use\n * @param address    Token account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Token account information\n */\nexport async function getAccount(\n    connection: Connection,\n    address: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID\n): Promise<Account> {\n    const info = await connection.getAccountInfo(address, commitment);\n    if (!info) throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n    if (info.data.length != ACCOUNT_SIZE) throw new TokenInvalidAccountSizeError();\n\n    const rawAccount = AccountLayout.decode(info.data);\n\n    return {\n        address,\n        mint: rawAccount.mint,\n        owner: rawAccount.owner,\n        amount: rawAccount.amount,\n        delegate: rawAccount.delegateOption ? rawAccount.delegate : null,\n        delegatedAmount: rawAccount.delegatedAmount,\n        isInitialized: rawAccount.state !== AccountState.Uninitialized,\n        isFrozen: rawAccount.state === AccountState.Frozen,\n        isNative: !!rawAccount.isNativeOption,\n        rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,\n        closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null,\n    };\n}\n\n/** Get the minimum lamport balance for a token account to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptAccount(\n    connection: Connection,\n    commitment?: Commitment\n): Promise<number> {\n    return await connection.getMinimumBalanceForRentExemption(ACCOUNT_SIZE, commitment);\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { struct, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey } from '@solana/buffer-layout-utils';\nimport { TOKEN_PROGRAM_ID } from './../constants.mjs';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError } from './../errors.mjs';\n/** Buffer layout for de/serializing a multisig */\n\nexport const MultisigLayout = struct([u8('m'), u8('n'), bool('isInitialized'), publicKey('signer1'), publicKey('signer2'), publicKey('signer3'), publicKey('signer4'), publicKey('signer5'), publicKey('signer6'), publicKey('signer7'), publicKey('signer8'), publicKey('signer9'), publicKey('signer10'), publicKey('signer11')]);\n/** Byte length of a multisig */\n\nexport const MULTISIG_SIZE = MultisigLayout.span;\n/**\n * Retrieve information about a multisig\n *\n * @param connection Connection to use\n * @param address    Multisig account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Multisig information\n */\n\nexport async function getMultisig(connection, address, commitment) {\n  let programId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TOKEN_PROGRAM_ID;\n  const info = await connection.getAccountInfo(address, commitment);\n  if (!info) throw new TokenAccountNotFoundError();\n  if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n  if (info.data.length != MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\n  return {\n    address,\n    ...MultisigLayout.decode(info.data)\n  };\n}\n/** Get the minimum lamport balance for a multisig to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\n\nexport async function getMinimumBalanceForRentExemptMultisig(connection, commitment) {\n  return await connection.getMinimumBalanceForRentExemption(MULTISIG_SIZE, commitment);\n}","map":{"version":3,"mappings":"AAAA,SAASA,MAAT,EAAiBC,EAAjB,QAA2B,uBAA3B;AACA,SAASC,IAAT,EAAeC,SAAf,QAAgC,6BAAhC;AAEA,SAASC,gBAAT,QAAiC,oBAAjC;AACA,SAASC,yBAAT,EAAoCC,6BAApC,EAAmEC,4BAAnE,QAAuG,iBAAvG;AA6BA;;AACA,OAAO,MAAMC,cAAc,GAAGR,MAAM,CAAc,CAC9CC,EAAE,CAAC,GAAD,CAD4C,EAE9CA,EAAE,CAAC,GAAD,CAF4C,EAG9CC,IAAI,CAAC,eAAD,CAH0C,EAI9CC,SAAS,CAAC,SAAD,CAJqC,EAK9CA,SAAS,CAAC,SAAD,CALqC,EAM9CA,SAAS,CAAC,SAAD,CANqC,EAO9CA,SAAS,CAAC,SAAD,CAPqC,EAQ9CA,SAAS,CAAC,SAAD,CARqC,EAS9CA,SAAS,CAAC,SAAD,CATqC,EAU9CA,SAAS,CAAC,SAAD,CAVqC,EAW9CA,SAAS,CAAC,SAAD,CAXqC,EAY9CA,SAAS,CAAC,SAAD,CAZqC,EAa9CA,SAAS,CAAC,UAAD,CAbqC,EAc9CA,SAAS,CAAC,UAAD,CAdqC,CAAd,CAA7B;AAiBP;;AACA,OAAO,MAAMM,aAAa,GAAGD,cAAc,CAACE,IAArC;AAEP;;;;;;;;;;;AAUA,OAAO,eAAeC,WAAf,CACHC,UADG,EAEHC,OAFG,EAGHC,UAHG,EAIyB;EAAA,IAA5BC,SAA4B,uEAAhBX,gBAAgB;EAE5B,MAAMY,IAAI,GAAG,MAAMJ,UAAU,CAACK,cAAX,CAA0BJ,OAA1B,EAAmCC,UAAnC,CAAnB;EACA,IAAI,CAACE,IAAL,EAAW,MAAM,IAAIX,yBAAJ,EAAN;EACX,IAAI,CAACW,IAAI,CAACE,KAAL,CAAWC,MAAX,CAAkBJ,SAAlB,CAAL,EAAmC,MAAM,IAAIT,6BAAJ,EAAN;EACnC,IAAIU,IAAI,CAACI,IAAL,CAAUC,MAAV,IAAoBZ,aAAxB,EAAuC,MAAM,IAAIF,4BAAJ,EAAN;EAEvC,OAAO;IAAEM,OAAF;IAAW,GAAGL,cAAc,CAACc,MAAf,CAAsBN,IAAI,CAACI,IAA3B;EAAd,CAAP;AACH;AAED;;;;;;;;AAOA,OAAO,eAAeG,sCAAf,CACHX,UADG,EAEHE,UAFG,EAEoB;EAEvB,OAAO,MAAMF,UAAU,CAACY,iCAAX,CAA6Cf,aAA7C,EAA4DK,UAA5D,CAAb;AACH","names":["struct","u8","bool","publicKey","TOKEN_PROGRAM_ID","TokenAccountNotFoundError","TokenInvalidAccountOwnerError","TokenInvalidAccountSizeError","MultisigLayout","MULTISIG_SIZE","span","getMultisig","connection","address","commitment","programId","info","getAccountInfo","owner","equals","data","length","decode","getMinimumBalanceForRentExemptMultisig","getMinimumBalanceForRentExemption"],"sources":["/Users/khairulamirinrohmat/nft-access/bedrock-nft-access/node_modules/@solana/spl-token/src/state/multisig.ts"],"sourcesContent":["import { struct, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey } from '@solana/buffer-layout-utils';\nimport { Commitment, Connection, PublicKey } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from '../constants';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError } from '../errors';\n\n/** Information about a multisig */\nexport interface Multisig {\n    /** Address of the multisig */\n    address: PublicKey;\n    /** Number of signers required */\n    m: number;\n    /** Number of possible signers, corresponds to the number of `signers` that are valid */\n    n: number;\n    /** Is this mint initialized */\n    isInitialized: boolean;\n    /** Full set of signers, of which `n` are valid */\n    signer1: PublicKey;\n    signer2: PublicKey;\n    signer3: PublicKey;\n    signer4: PublicKey;\n    signer5: PublicKey;\n    signer6: PublicKey;\n    signer7: PublicKey;\n    signer8: PublicKey;\n    signer9: PublicKey;\n    signer10: PublicKey;\n    signer11: PublicKey;\n}\n\n/** Multisig as stored by the program */\nexport type RawMultisig = Omit<Multisig, 'address'>;\n\n/** Buffer layout for de/serializing a multisig */\nexport const MultisigLayout = struct<RawMultisig>([\n    u8('m'),\n    u8('n'),\n    bool('isInitialized'),\n    publicKey('signer1'),\n    publicKey('signer2'),\n    publicKey('signer3'),\n    publicKey('signer4'),\n    publicKey('signer5'),\n    publicKey('signer6'),\n    publicKey('signer7'),\n    publicKey('signer8'),\n    publicKey('signer9'),\n    publicKey('signer10'),\n    publicKey('signer11'),\n]);\n\n/** Byte length of a multisig */\nexport const MULTISIG_SIZE = MultisigLayout.span;\n\n/**\n * Retrieve information about a multisig\n *\n * @param connection Connection to use\n * @param address    Multisig account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Multisig information\n */\nexport async function getMultisig(\n    connection: Connection,\n    address: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID\n): Promise<Multisig> {\n    const info = await connection.getAccountInfo(address, commitment);\n    if (!info) throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n    if (info.data.length != MULTISIG_SIZE) throw new TokenInvalidAccountSizeError();\n\n    return { address, ...MultisigLayout.decode(info.data) };\n}\n\n/** Get the minimum lamport balance for a multisig to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMultisig(\n    connection: Connection,\n    commitment?: Commitment\n): Promise<number> {\n    return await connection.getMinimumBalanceForRentExemption(MULTISIG_SIZE, commitment);\n}\n"]},"metadata":{},"sourceType":"module"}
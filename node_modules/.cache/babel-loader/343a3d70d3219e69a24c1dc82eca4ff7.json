{"ast":null,"code":"import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { PublicKey } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from './../constants.mjs';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError, TokenOwnerOffCurveError } from './../errors.mjs';\n/** Buffer layout for de/serializing a mint */\n\nexport const MintLayout = struct([u32('mintAuthorityOption'), publicKey('mintAuthority'), u64('supply'), u8('decimals'), bool('isInitialized'), u32('freezeAuthorityOption'), publicKey('freezeAuthority')]);\n/** Byte length of a mint */\n\nexport const MINT_SIZE = MintLayout.span;\n/**\n * Retrieve information about a mint\n *\n * @param connection Connection to use\n * @param address    Mint account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Mint information\n */\n\nexport async function getMint(connection, address, commitment) {\n  let programId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TOKEN_PROGRAM_ID;\n  const info = await connection.getAccountInfo(address, commitment);\n  if (!info) throw new TokenAccountNotFoundError();\n  if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n  if (info.data.length != MINT_SIZE) throw new TokenInvalidAccountSizeError();\n  const rawMint = MintLayout.decode(info.data);\n  return {\n    address,\n    mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,\n    supply: rawMint.supply,\n    decimals: rawMint.decimals,\n    isInitialized: rawMint.isInitialized,\n    freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null\n  };\n}\n/** Get the minimum lamport balance for a mint to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\n\nexport async function getMinimumBalanceForRentExemptMint(connection, commitment) {\n  return await connection.getMinimumBalanceForRentExemption(MINT_SIZE, commitment);\n}\n/**\n * Get the address of the associated token account for a given mint and owner\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the associated token account\n */\n\nexport async function getAssociatedTokenAddress(mint, owner) {\n  let allowOwnerOffCurve = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let programId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TOKEN_PROGRAM_ID;\n  let associatedTokenProgramId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ASSOCIATED_TOKEN_PROGRAM_ID;\n  if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer())) throw new TokenOwnerOffCurveError();\n  const [address] = await PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);\n  return address;\n}","map":{"version":3,"mappings":"AAAA,SAASA,MAAT,EAAiBC,GAAjB,EAAsBC,EAAtB,QAAgC,uBAAhC;AACA,SAASC,IAAT,EAAeC,SAAf,EAA0BC,GAA1B,QAAqC,6BAArC;AACA,SAAiCC,SAAjC,QAAkD,iBAAlD;AACA,SAASC,2BAAT,EAAsCC,gBAAtC,QAA8D,oBAA9D;AACA,SACIC,yBADJ,EAEIC,6BAFJ,EAGIC,4BAHJ,EAIIC,uBAJJ,QAKO,iBALP;AAqCA;;AACA,OAAO,MAAMC,UAAU,GAAGb,MAAM,CAAU,CACtCC,GAAG,CAAC,qBAAD,CADmC,EAEtCG,SAAS,CAAC,eAAD,CAF6B,EAGtCC,GAAG,CAAC,QAAD,CAHmC,EAItCH,EAAE,CAAC,UAAD,CAJoC,EAKtCC,IAAI,CAAC,eAAD,CALkC,EAMtCF,GAAG,CAAC,uBAAD,CANmC,EAOtCG,SAAS,CAAC,iBAAD,CAP6B,CAAV,CAAzB;AAUP;;AACA,OAAO,MAAMU,SAAS,GAAGD,UAAU,CAACE,IAA7B;AAEP;;;;;;;;;;;AAUA,OAAO,eAAeC,OAAf,CACHC,UADG,EAEHC,OAFG,EAGHC,UAHG,EAIyB;EAAA,IAA5BC,SAA4B,uEAAhBZ,gBAAgB;EAE5B,MAAMa,IAAI,GAAG,MAAMJ,UAAU,CAACK,cAAX,CAA0BJ,OAA1B,EAAmCC,UAAnC,CAAnB;EACA,IAAI,CAACE,IAAL,EAAW,MAAM,IAAIZ,yBAAJ,EAAN;EACX,IAAI,CAACY,IAAI,CAACE,KAAL,CAAWC,MAAX,CAAkBJ,SAAlB,CAAL,EAAmC,MAAM,IAAIV,6BAAJ,EAAN;EACnC,IAAIW,IAAI,CAACI,IAAL,CAAUC,MAAV,IAAoBZ,SAAxB,EAAmC,MAAM,IAAIH,4BAAJ,EAAN;EAEnC,MAAMgB,OAAO,GAAGd,UAAU,CAACe,MAAX,CAAkBP,IAAI,CAACI,IAAvB,CAAhB;EAEA,OAAO;IACHP,OADG;IAEHW,aAAa,EAAEF,OAAO,CAACG,mBAAR,GAA8BH,OAAO,CAACE,aAAtC,GAAsD,IAFlE;IAGHE,MAAM,EAAEJ,OAAO,CAACI,MAHb;IAIHC,QAAQ,EAAEL,OAAO,CAACK,QAJf;IAKHC,aAAa,EAAEN,OAAO,CAACM,aALpB;IAMHC,eAAe,EAAEP,OAAO,CAACQ,qBAAR,GAAgCR,OAAO,CAACO,eAAxC,GAA0D;EANxE,CAAP;AAQH;AAED;;;;;;;;AAOA,OAAO,eAAeE,kCAAf,CACHnB,UADG,EAEHE,UAFG,EAEoB;EAEvB,OAAO,MAAMF,UAAU,CAACoB,iCAAX,CAA6CvB,SAA7C,EAAwDK,UAAxD,CAAb;AACH;AAED;;;;;;;;;;;;AAWA,OAAO,eAAemB,yBAAf,CACHC,IADG,EAEHhB,KAFG,EAKmD;EAAA,IAFtDiB,kBAEsD,uEAFjC,KAEiC;EAAA,IADtDpB,SACsD,uEAD1CZ,gBAC0C;EAAA,IAAtDiC,wBAAsD,uEAA3BlC,2BAA2B;EAEtD,IAAI,CAACiC,kBAAD,IAAuB,CAAClC,SAAS,CAACoC,SAAV,CAAoBnB,KAAK,CAACoB,QAAN,EAApB,CAA5B,EAAmE,MAAM,IAAI/B,uBAAJ,EAAN;EAEnE,MAAM,CAACM,OAAD,IAAY,MAAMZ,SAAS,CAACsC,kBAAV,CACpB,CAACrB,KAAK,CAACoB,QAAN,EAAD,EAAmBvB,SAAS,CAACuB,QAAV,EAAnB,EAAyCJ,IAAI,CAACI,QAAL,EAAzC,CADoB,EAEpBF,wBAFoB,CAAxB;EAKA,OAAOvB,OAAP;AACH","names":["struct","u32","u8","bool","publicKey","u64","PublicKey","ASSOCIATED_TOKEN_PROGRAM_ID","TOKEN_PROGRAM_ID","TokenAccountNotFoundError","TokenInvalidAccountOwnerError","TokenInvalidAccountSizeError","TokenOwnerOffCurveError","MintLayout","MINT_SIZE","span","getMint","connection","address","commitment","programId","info","getAccountInfo","owner","equals","data","length","rawMint","decode","mintAuthority","mintAuthorityOption","supply","decimals","isInitialized","freezeAuthority","freezeAuthorityOption","getMinimumBalanceForRentExemptMint","getMinimumBalanceForRentExemption","getAssociatedTokenAddress","mint","allowOwnerOffCurve","associatedTokenProgramId","isOnCurve","toBuffer","findProgramAddress"],"sources":["/Users/khairulamirinrohmat/nft-access/bedrock-nft-access/node_modules/@solana/spl-token/src/state/mint.ts"],"sourcesContent":["import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { Commitment, Connection, PublicKey } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenAccountNotFoundError,\n    TokenInvalidAccountOwnerError,\n    TokenInvalidAccountSizeError,\n    TokenOwnerOffCurveError,\n} from '../errors';\n\n/** Information about a mint */\nexport interface Mint {\n    /** Address of the mint */\n    address: PublicKey;\n    /**\n     * Optional authority used to mint new tokens. The mint authority may only be provided during mint creation.\n     * If no mint authority is present then the mint has a fixed supply and no further tokens may be minted.\n     */\n    mintAuthority: PublicKey | null;\n    /** Total supply of tokens */\n    supply: bigint;\n    /** Number of base 10 digits to the right of the decimal place */\n    decimals: number;\n    /** Is this mint initialized */\n    isInitialized: boolean;\n    /** Optional authority to freeze token accounts */\n    freezeAuthority: PublicKey | null;\n}\n\n/** Mint as stored by the program */\nexport interface RawMint {\n    mintAuthorityOption: 1 | 0;\n    mintAuthority: PublicKey;\n    supply: bigint;\n    decimals: number;\n    isInitialized: boolean;\n    freezeAuthorityOption: 1 | 0;\n    freezeAuthority: PublicKey;\n}\n\n/** Buffer layout for de/serializing a mint */\nexport const MintLayout = struct<RawMint>([\n    u32('mintAuthorityOption'),\n    publicKey('mintAuthority'),\n    u64('supply'),\n    u8('decimals'),\n    bool('isInitialized'),\n    u32('freezeAuthorityOption'),\n    publicKey('freezeAuthority'),\n]);\n\n/** Byte length of a mint */\nexport const MINT_SIZE = MintLayout.span;\n\n/**\n * Retrieve information about a mint\n *\n * @param connection Connection to use\n * @param address    Mint account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Mint information\n */\nexport async function getMint(\n    connection: Connection,\n    address: PublicKey,\n    commitment?: Commitment,\n    programId = TOKEN_PROGRAM_ID\n): Promise<Mint> {\n    const info = await connection.getAccountInfo(address, commitment);\n    if (!info) throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId)) throw new TokenInvalidAccountOwnerError();\n    if (info.data.length != MINT_SIZE) throw new TokenInvalidAccountSizeError();\n\n    const rawMint = MintLayout.decode(info.data);\n\n    return {\n        address,\n        mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,\n        supply: rawMint.supply,\n        decimals: rawMint.decimals,\n        isInitialized: rawMint.isInitialized,\n        freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,\n    };\n}\n\n/** Get the minimum lamport balance for a mint to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMint(\n    connection: Connection,\n    commitment?: Commitment\n): Promise<number> {\n    return await connection.getMinimumBalanceForRentExemption(MINT_SIZE, commitment);\n}\n\n/**\n * Get the address of the associated token account for a given mint and owner\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the associated token account\n */\nexport async function getAssociatedTokenAddress(\n    mint: PublicKey,\n    owner: PublicKey,\n    allowOwnerOffCurve = false,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID\n): Promise<PublicKey> {\n    if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer())) throw new TokenOwnerOffCurveError();\n\n    const [address] = await PublicKey.findProgramAddress(\n        [owner.toBuffer(), programId.toBuffer(), mint.toBuffer()],\n        associatedTokenProgramId\n    );\n\n    return address;\n}\n"]},"metadata":{},"sourceType":"module"}
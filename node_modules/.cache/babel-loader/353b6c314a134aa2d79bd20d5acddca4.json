{"ast":null,"code":"import { createTransferCheckedInstruction, getAccount, getAssociatedTokenAddress, getMint } from '@solana/spl-token';\nimport { LAMPORTS_PER_SOL, SystemProgram, Transaction, TransactionInstruction } from '@solana/web3.js';\nimport BigNumber from 'bignumber.js';\nimport { MEMO_PROGRAM_ID, SOL_DECIMALS, TEN } from './constants.mjs';\n/**\n * Thrown when a Solana Pay transfer transaction can't be created from the fields provided.\n */\n\nexport class CreateTransferError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = 'CreateTransferError';\n  }\n\n}\n/**\n * Create a Solana Pay transfer transaction.\n *\n * @param connection - A connection to the cluster.\n * @param sender - Account that will send the transfer.\n * @param fields - Fields of a Solana Pay transfer request URL.\n * @param options - Options for `getRecentBlockhash`.\n *\n * @throws {CreateTransferError}\n */\n\nexport async function createTransfer(connection, sender, _ref) {\n  let {\n    recipient,\n    amount,\n    splToken,\n    reference,\n    memo\n  } = _ref;\n  let {\n    commitment\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  // Check that the sender and recipient accounts exist\n  const senderInfo = await connection.getAccountInfo(sender);\n  if (!senderInfo) throw new CreateTransferError('sender not found');\n  const recipientInfo = await connection.getAccountInfo(recipient);\n  if (!recipientInfo) throw new CreateTransferError('recipient not found'); // A native SOL or SPL token transfer instruction\n\n  const instruction = splToken ? await createSPLTokenInstruction(recipient, amount, splToken, sender, connection) : await createSystemInstruction(recipient, amount, sender, connection); // If reference accounts are provided, add them to the transfer instruction\n\n  if (reference) {\n    if (!Array.isArray(reference)) {\n      reference = [reference];\n    }\n\n    for (const pubkey of reference) {\n      instruction.keys.push({\n        pubkey,\n        isWritable: false,\n        isSigner: false\n      });\n    }\n  } // Create the transaction\n\n\n  const transaction = new Transaction();\n  transaction.feePayer = sender;\n  transaction.recentBlockhash = (await connection.getRecentBlockhash(commitment)).blockhash; // If a memo is provided, add it to the transaction before adding the transfer instruction\n\n  if (memo != null) {\n    transaction.add(new TransactionInstruction({\n      programId: MEMO_PROGRAM_ID,\n      keys: [],\n      data: Buffer.from(memo, 'utf8')\n    }));\n  } // Add the transfer instruction to the transaction\n\n\n  transaction.add(instruction);\n  return transaction;\n}\n\nasync function createSystemInstruction(recipient, amount, sender, connection) {\n  // Check that the sender and recipient accounts exist\n  const senderInfo = await connection.getAccountInfo(sender);\n  if (!senderInfo) throw new CreateTransferError('sender not found');\n  const recipientInfo = await connection.getAccountInfo(recipient);\n  if (!recipientInfo) throw new CreateTransferError('recipient not found'); // Check that the sender and recipient are valid native accounts\n\n  if (!senderInfo.owner.equals(SystemProgram.programId)) throw new CreateTransferError('sender owner invalid');\n  if (senderInfo.executable) throw new CreateTransferError('sender executable');\n  if (!recipientInfo.owner.equals(SystemProgram.programId)) throw new CreateTransferError('recipient owner invalid');\n  if (recipientInfo.executable) throw new CreateTransferError('recipient executable'); // Check that the amount provided doesn't have greater precision than SOL\n\n  if (amount.decimalPlaces() > SOL_DECIMALS) throw new CreateTransferError('amount decimals invalid'); // Convert input decimal amount to integer lamports\n\n  amount = amount.times(LAMPORTS_PER_SOL).integerValue(BigNumber.ROUND_FLOOR); // Check that the sender has enough lamports\n\n  const lamports = amount.toNumber();\n  if (lamports > senderInfo.lamports) throw new CreateTransferError('insufficient funds'); // Create an instruction to transfer native SOL\n\n  return SystemProgram.transfer({\n    fromPubkey: sender,\n    toPubkey: recipient,\n    lamports\n  });\n}\n\nasync function createSPLTokenInstruction(recipient, amount, splToken, sender, connection) {\n  // Check that the token provided is an initialized mint\n  const mint = await getMint(connection, splToken);\n  if (!mint.isInitialized) throw new CreateTransferError('mint not initialized'); // Check that the amount provided doesn't have greater precision than the mint\n\n  if (amount.decimalPlaces() > mint.decimals) throw new CreateTransferError('amount decimals invalid'); // Convert input decimal amount to integer tokens according to the mint decimals\n\n  amount = amount.times(TEN.pow(mint.decimals)).integerValue(BigNumber.ROUND_FLOOR); // Get the sender's ATA and check that the account exists and can send tokens\n\n  const senderATA = await getAssociatedTokenAddress(splToken, sender);\n  const senderAccount = await getAccount(connection, senderATA);\n  if (!senderAccount.isInitialized) throw new CreateTransferError('sender not initialized');\n  if (senderAccount.isFrozen) throw new CreateTransferError('sender frozen'); // Get the recipient's ATA and check that the account exists and can receive tokens\n\n  const recipientATA = await getAssociatedTokenAddress(splToken, recipient);\n  const recipientAccount = await getAccount(connection, recipientATA);\n  if (!recipientAccount.isInitialized) throw new CreateTransferError('recipient not initialized');\n  if (recipientAccount.isFrozen) throw new CreateTransferError('recipient frozen'); // Check that the sender has enough tokens\n\n  const tokens = BigInt(String(amount));\n  if (tokens > senderAccount.amount) throw new CreateTransferError('insufficient funds'); // Create an instruction to transfer SPL tokens, asserting the mint and decimals match\n\n  return createTransferCheckedInstruction(senderATA, splToken, recipientATA, sender, tokens, mint.decimals);\n}","map":{"version":3,"mappings":"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","names":["createTransferCheckedInstruction","getAccount","getAssociatedTokenAddress","getMint","LAMPORTS_PER_SOL","SystemProgram","Transaction","TransactionInstruction","BigNumber","MEMO_PROGRAM_ID","SOL_DECIMALS","TEN","CreateTransferError","Error","constructor","createTransfer","connection","sender","recipient","amount","splToken","reference","memo","commitment","senderInfo","getAccountInfo","recipientInfo","instruction","createSPLTokenInstruction","createSystemInstruction","Array","isArray","pubkey","keys","push","isWritable","isSigner","transaction","feePayer","recentBlockhash","getRecentBlockhash","blockhash","add","programId","data","Buffer","from","owner","equals","executable","decimalPlaces","times","integerValue","ROUND_FLOOR","lamports","toNumber","transfer","fromPubkey","toPubkey","mint","isInitialized","decimals","pow","senderATA","senderAccount","isFrozen","recipientATA","recipientAccount","tokens","BigInt","String"],"sources":["/Users/khairulamirinrohmat/nft-access/bedrock-nft-access/node_modules/@solana/pay/src/createTransfer.ts"],"sourcesContent":["import { createTransferCheckedInstruction, getAccount, getAssociatedTokenAddress, getMint } from '@solana/spl-token';\nimport {\n    Commitment,\n    Connection,\n    LAMPORTS_PER_SOL,\n    PublicKey,\n    SystemProgram,\n    Transaction,\n    TransactionInstruction,\n} from '@solana/web3.js';\nimport BigNumber from 'bignumber.js';\nimport { MEMO_PROGRAM_ID, SOL_DECIMALS, TEN } from './constants';\nimport { Amount, Memo, Recipient, References, SPLToken } from './types';\n\n/**\n * Thrown when a Solana Pay transfer transaction can't be created from the fields provided.\n */\nexport class CreateTransferError extends Error {\n    name = 'CreateTransferError';\n}\n\n/**\n * Fields of a Solana Pay transfer request URL.\n */\nexport interface CreateTransferFields {\n    /** `recipient` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#recipient). */\n    recipient: Recipient;\n    /** `amount` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#amount). */\n    amount: Amount;\n    /** `spl-token` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#spl-token). */\n    splToken?: SPLToken;\n    /** `reference` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#reference). */\n    reference?: References;\n    /** `memo` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#memo). */\n    memo?: Memo;\n}\n\n/**\n * Create a Solana Pay transfer transaction.\n *\n * @param connection - A connection to the cluster.\n * @param sender - Account that will send the transfer.\n * @param fields - Fields of a Solana Pay transfer request URL.\n * @param options - Options for `getRecentBlockhash`.\n *\n * @throws {CreateTransferError}\n */\nexport async function createTransfer(\n    connection: Connection,\n    sender: PublicKey,\n    { recipient, amount, splToken, reference, memo }: CreateTransferFields,\n    { commitment }: { commitment?: Commitment } = {}\n): Promise<Transaction> {\n    // Check that the sender and recipient accounts exist\n    const senderInfo = await connection.getAccountInfo(sender);\n    if (!senderInfo) throw new CreateTransferError('sender not found');\n\n    const recipientInfo = await connection.getAccountInfo(recipient);\n    if (!recipientInfo) throw new CreateTransferError('recipient not found');\n\n    // A native SOL or SPL token transfer instruction\n    const instruction = splToken\n        ? await createSPLTokenInstruction(recipient, amount, splToken, sender, connection)\n        : await createSystemInstruction(recipient, amount, sender, connection);\n\n    // If reference accounts are provided, add them to the transfer instruction\n    if (reference) {\n        if (!Array.isArray(reference)) {\n            reference = [reference];\n        }\n\n        for (const pubkey of reference) {\n            instruction.keys.push({ pubkey, isWritable: false, isSigner: false });\n        }\n    }\n\n    // Create the transaction\n    const transaction = new Transaction();\n    transaction.feePayer = sender;\n    transaction.recentBlockhash = (await connection.getRecentBlockhash(commitment)).blockhash;\n\n    // If a memo is provided, add it to the transaction before adding the transfer instruction\n    if (memo != null) {\n        transaction.add(\n            new TransactionInstruction({\n                programId: MEMO_PROGRAM_ID,\n                keys: [],\n                data: Buffer.from(memo, 'utf8'),\n            })\n        );\n    }\n\n    // Add the transfer instruction to the transaction\n    transaction.add(instruction);\n\n    return transaction;\n}\n\nasync function createSystemInstruction(\n    recipient: PublicKey,\n    amount: BigNumber,\n    sender: PublicKey,\n    connection: Connection\n): Promise<TransactionInstruction> {\n    // Check that the sender and recipient accounts exist\n    const senderInfo = await connection.getAccountInfo(sender);\n    if (!senderInfo) throw new CreateTransferError('sender not found');\n\n    const recipientInfo = await connection.getAccountInfo(recipient);\n    if (!recipientInfo) throw new CreateTransferError('recipient not found');\n\n    // Check that the sender and recipient are valid native accounts\n    if (!senderInfo.owner.equals(SystemProgram.programId)) throw new CreateTransferError('sender owner invalid');\n    if (senderInfo.executable) throw new CreateTransferError('sender executable');\n    if (!recipientInfo.owner.equals(SystemProgram.programId)) throw new CreateTransferError('recipient owner invalid');\n    if (recipientInfo.executable) throw new CreateTransferError('recipient executable');\n\n    // Check that the amount provided doesn't have greater precision than SOL\n    if (amount.decimalPlaces() > SOL_DECIMALS) throw new CreateTransferError('amount decimals invalid');\n\n    // Convert input decimal amount to integer lamports\n    amount = amount.times(LAMPORTS_PER_SOL).integerValue(BigNumber.ROUND_FLOOR);\n\n    // Check that the sender has enough lamports\n    const lamports = amount.toNumber();\n    if (lamports > senderInfo.lamports) throw new CreateTransferError('insufficient funds');\n\n    // Create an instruction to transfer native SOL\n    return SystemProgram.transfer({\n        fromPubkey: sender,\n        toPubkey: recipient,\n        lamports,\n    });\n}\n\nasync function createSPLTokenInstruction(\n    recipient: PublicKey,\n    amount: BigNumber,\n    splToken: PublicKey,\n    sender: PublicKey,\n    connection: Connection\n): Promise<TransactionInstruction> {\n    // Check that the token provided is an initialized mint\n    const mint = await getMint(connection, splToken);\n    if (!mint.isInitialized) throw new CreateTransferError('mint not initialized');\n\n    // Check that the amount provided doesn't have greater precision than the mint\n    if (amount.decimalPlaces() > mint.decimals) throw new CreateTransferError('amount decimals invalid');\n\n    // Convert input decimal amount to integer tokens according to the mint decimals\n    amount = amount.times(TEN.pow(mint.decimals)).integerValue(BigNumber.ROUND_FLOOR);\n\n    // Get the sender's ATA and check that the account exists and can send tokens\n    const senderATA = await getAssociatedTokenAddress(splToken, sender);\n    const senderAccount = await getAccount(connection, senderATA);\n    if (!senderAccount.isInitialized) throw new CreateTransferError('sender not initialized');\n    if (senderAccount.isFrozen) throw new CreateTransferError('sender frozen');\n\n    // Get the recipient's ATA and check that the account exists and can receive tokens\n    const recipientATA = await getAssociatedTokenAddress(splToken, recipient);\n    const recipientAccount = await getAccount(connection, recipientATA);\n    if (!recipientAccount.isInitialized) throw new CreateTransferError('recipient not initialized');\n    if (recipientAccount.isFrozen) throw new CreateTransferError('recipient frozen');\n\n    // Check that the sender has enough tokens\n    const tokens = BigInt(String(amount));\n    if (tokens > senderAccount.amount) throw new CreateTransferError('insufficient funds');\n\n    // Create an instruction to transfer SPL tokens, asserting the mint and decimals match\n    return createTransferCheckedInstruction(senderATA, splToken, recipientATA, sender, tokens, mint.decimals);\n}\n"]},"metadata":{},"sourceType":"module"}
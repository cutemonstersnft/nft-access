{"ast":null,"code":"/**\n * Thrown when no transaction signature can be found referencing a given public key.\n */\nexport class FindReferenceError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = 'FindReferenceError';\n  }\n\n}\n/**\n * Find the oldest transaction signature referencing a given public key.\n *\n * @param connection - A connection to the cluster.\n * @param reference - `reference` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#reference).\n * @param options - Options for `getSignaturesForAddress`.\n *\n * @throws {FindReferenceError}\n */\n\nexport async function findReference(connection, reference) {\n  let {\n    finality,\n    ...options\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const signatures = await connection.getSignaturesForAddress(reference, options, finality);\n  const length = signatures.length;\n  if (!length) throw new FindReferenceError('not found'); // If one or more transaction signatures are found under the limit, return the oldest one.\n\n  const oldest = signatures[length - 1];\n  if (length < ((options === null || options === void 0 ? void 0 : options.limit) || 1000)) return oldest;\n\n  try {\n    // In the unlikely event that signatures up to the limit are found, recursively find the oldest one.\n    return await findReference(connection, reference, {\n      finality,\n      ...options,\n      before: oldest.signature\n    });\n  } catch (error) {\n    // If the signatures found were exactly at the limit, there won't be more to find, so return the oldest one.\n    if (error instanceof FindReferenceError) return oldest;\n    throw error;\n  }\n}","map":{"version":3,"mappings":"AAGA;;;AAGA,OAAM,MAAOA,kBAAP,SAAkCC,KAAlC,CAAuC;EAA7CC;;IACI,YAAO,oBAAP;EACH;;AAF4C;AAI7C;;;;;;;;;;AASA,OAAO,eAAeC,aAAf,CACHC,UADG,EAEHC,SAFG,EAGiF;EAAA,IAApF;IAAEC,QAAF;IAAY,GAAGC;EAAf,CAAoF,uEAAF,EAAE;EAEpF,MAAMC,UAAU,GAAG,MAAMJ,UAAU,CAACK,uBAAX,CAAmCJ,SAAnC,EAA8CE,OAA9C,EAAuDD,QAAvD,CAAzB;EAEA,MAAMI,MAAM,GAAGF,UAAU,CAACE,MAA1B;EACA,IAAI,CAACA,MAAL,EAAa,MAAM,IAAIV,kBAAJ,CAAuB,WAAvB,CAAN,CALuE,CAOpF;;EACA,MAAMW,MAAM,GAAGH,UAAU,CAACE,MAAM,GAAG,CAAV,CAAzB;EACA,IAAIA,MAAM,IAAI,QAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEE,KAAT,KAAkB,IAAtB,CAAV,EAAuC,OAAOD,MAAP;;EAEvC,IAAI;IACA;IACA,OAAO,MAAMR,aAAa,CAACC,UAAD,EAAaC,SAAb,EAAwB;MAAEC,QAAF;MAAY,GAAGC,OAAf;MAAwBM,MAAM,EAAEF,MAAM,CAACG;IAAvC,CAAxB,CAA1B;EACH,CAHD,CAGE,OAAOC,KAAP,EAAmB;IACjB;IACA,IAAIA,KAAK,YAAYf,kBAArB,EAAyC,OAAOW,MAAP;IACzC,MAAMI,KAAN;EACH;AACJ","names":["FindReferenceError","Error","constructor","findReference","connection","reference","finality","options","signatures","getSignaturesForAddress","length","oldest","limit","before","signature","error"],"sources":["/Users/khairulamirinrohmat/nft-access/bedrock-nft-access/node_modules/@solana/pay/src/findReference.ts"],"sourcesContent":["import { ConfirmedSignatureInfo, Connection, Finality, SignaturesForAddressOptions } from '@solana/web3.js';\nimport { Reference } from './types';\n\n/**\n * Thrown when no transaction signature can be found referencing a given public key.\n */\nexport class FindReferenceError extends Error {\n    name = 'FindReferenceError';\n}\n\n/**\n * Find the oldest transaction signature referencing a given public key.\n *\n * @param connection - A connection to the cluster.\n * @param reference - `reference` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#reference).\n * @param options - Options for `getSignaturesForAddress`.\n *\n * @throws {FindReferenceError}\n */\nexport async function findReference(\n    connection: Connection,\n    reference: Reference,\n    { finality, ...options }: SignaturesForAddressOptions & { finality?: Finality } = {}\n): Promise<ConfirmedSignatureInfo> {\n    const signatures = await connection.getSignaturesForAddress(reference, options, finality);\n\n    const length = signatures.length;\n    if (!length) throw new FindReferenceError('not found');\n\n    // If one or more transaction signatures are found under the limit, return the oldest one.\n    const oldest = signatures[length - 1];\n    if (length < (options?.limit || 1000)) return oldest;\n\n    try {\n        // In the unlikely event that signatures up to the limit are found, recursively find the oldest one.\n        return await findReference(connection, reference, { finality, ...options, before: oldest.signature });\n    } catch (error: any) {\n        // If the signatures found were exactly at the limit, there won't be more to find, so return the oldest one.\n        if (error instanceof FindReferenceError) return oldest;\n        throw error;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}
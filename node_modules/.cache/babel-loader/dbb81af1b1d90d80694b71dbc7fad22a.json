{"ast":null,"code":"import { Transaction } from '@solana/web3.js';\nimport fetch from 'cross-fetch';\nimport { toUint8Array } from 'js-base64';\nimport nacl from 'tweetnacl';\n/**\n * Thrown when a transaction response can't be fetched.\n */\n\nexport class FetchTransactionError extends Error {\n  constructor() {\n    super(...arguments);\n    this.name = 'FetchTransactionError';\n  }\n\n}\n/**\n * Fetch a transaction from a Solana Pay transaction request link.\n *\n * @param connection - A connection to the cluster.\n * @param account - Account that may sign the transaction.\n * @param link - `link` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#link).\n * @param options - Options for `getRecentBlockhash`.\n *\n * @throws {FetchTransactionError}\n */\n\nexport async function fetchTransaction(connection, account, link) {\n  let {\n    commitment\n  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const response = await fetch(String(link), {\n    method: 'POST',\n    mode: 'cors',\n    cache: 'no-cache',\n    credentials: 'omit',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      account\n    })\n  });\n  const json = await response.json();\n  if (!(json === null || json === void 0 ? void 0 : json.transaction)) throw new FetchTransactionError('missing transaction');\n  if (typeof json.transaction !== 'string') throw new FetchTransactionError('invalid transaction');\n  const transaction = Transaction.from(toUint8Array(json.transaction));\n  const {\n    signatures,\n    feePayer,\n    recentBlockhash\n  } = transaction;\n\n  if (signatures.length) {\n    if (!feePayer) throw new FetchTransactionError('missing fee payer');\n    if (!feePayer.equals(signatures[0].publicKey)) throw new FetchTransactionError('invalid fee payer');\n    if (!recentBlockhash) throw new FetchTransactionError('missing recent blockhash'); // A valid signature for everything except `account` must be provided.\n\n    const message = transaction.serializeMessage();\n\n    for (const {\n      signature,\n      publicKey\n    } of signatures) {\n      if (signature) {\n        if (!nacl.sign.detached.verify(message, signature, publicKey.toBuffer())) throw new FetchTransactionError('invalid signature');\n      } else if (publicKey.equals(account)) {\n        // If the only signature expected is for `account`, ignore the recent blockhash in the transaction.\n        if (signatures.length === 1) {\n          transaction.recentBlockhash = (await connection.getRecentBlockhash(commitment)).blockhash;\n        }\n      } else {\n        throw new FetchTransactionError('missing signature');\n      }\n    }\n  } else {\n    // Ignore the fee payer and recent blockhash in the transaction and initialize them.\n    transaction.feePayer = account;\n    transaction.recentBlockhash = (await connection.getRecentBlockhash(commitment)).blockhash;\n  }\n\n  return transaction;\n}","map":{"version":3,"mappings":"AAAA,SAA4CA,WAA5C,QAA+D,iBAA/D;AACA,OAAOC,KAAP,MAAkB,aAAlB;AACA,SAASC,YAAT,QAA6B,WAA7B;AACA,OAAOC,IAAP,MAAiB,WAAjB;AAEA;;;;AAGA,OAAM,MAAOC,qBAAP,SAAqCC,KAArC,CAA0C;EAAhDC;;IACI,YAAO,uBAAP;EACH;;AAF+C;AAIhD;;;;;;;;;;;AAUA,OAAO,eAAeC,gBAAf,CACHC,UADG,EAEHC,OAFG,EAGHC,IAHG,EAI6C;EAAA,IAAhD;IAAEC;EAAF,CAAgD,uEAAF,EAAE;EAEhD,MAAMC,QAAQ,GAAG,MAAMX,KAAK,CAACY,MAAM,CAACH,IAAD,CAAP,EAAe;IACvCI,MAAM,EAAE,MAD+B;IAEvCC,IAAI,EAAE,MAFiC;IAGvCC,KAAK,EAAE,UAHgC;IAIvCC,WAAW,EAAE,MAJ0B;IAKvCC,OAAO,EAAE;MACLC,MAAM,EAAE,kBADH;MAEL,gBAAgB;IAFX,CAL8B;IASvCC,IAAI,EAAEC,IAAI,CAACC,SAAL,CAAe;MAAEb;IAAF,CAAf;EATiC,CAAf,CAA5B;EAYA,MAAMc,IAAI,GAAG,MAAMX,QAAQ,CAACW,IAAT,EAAnB;EACA,IAAI,EAACA,IAAI,SAAJ,QAAI,WAAJ,GAAI,MAAJ,OAAI,CAAEC,WAAP,CAAJ,EAAwB,MAAM,IAAIpB,qBAAJ,CAA0B,qBAA1B,CAAN;EACxB,IAAI,OAAOmB,IAAI,CAACC,WAAZ,KAA4B,QAAhC,EAA0C,MAAM,IAAIpB,qBAAJ,CAA0B,qBAA1B,CAAN;EAE1C,MAAMoB,WAAW,GAAGxB,WAAW,CAACyB,IAAZ,CAAiBvB,YAAY,CAACqB,IAAI,CAACC,WAAN,CAA7B,CAApB;EACA,MAAM;IAAEE,UAAF;IAAcC,QAAd;IAAwBC;EAAxB,IAA4CJ,WAAlD;;EAEA,IAAIE,UAAU,CAACG,MAAf,EAAuB;IACnB,IAAI,CAACF,QAAL,EAAe,MAAM,IAAIvB,qBAAJ,CAA0B,mBAA1B,CAAN;IACf,IAAI,CAACuB,QAAQ,CAACG,MAAT,CAAgBJ,UAAU,CAAC,CAAD,CAAV,CAAcK,SAA9B,CAAL,EAA+C,MAAM,IAAI3B,qBAAJ,CAA0B,mBAA1B,CAAN;IAC/C,IAAI,CAACwB,eAAL,EAAsB,MAAM,IAAIxB,qBAAJ,CAA0B,0BAA1B,CAAN,CAHH,CAKnB;;IACA,MAAM4B,OAAO,GAAGR,WAAW,CAACS,gBAAZ,EAAhB;;IACA,KAAK,MAAM;MAAEC,SAAF;MAAaH;IAAb,CAAX,IAAuCL,UAAvC,EAAmD;MAC/C,IAAIQ,SAAJ,EAAe;QACX,IAAI,CAAC/B,IAAI,CAACgC,IAAL,CAAUC,QAAV,CAAmBC,MAAnB,CAA0BL,OAA1B,EAAmCE,SAAnC,EAA8CH,SAAS,CAACO,QAAV,EAA9C,CAAL,EACI,MAAM,IAAIlC,qBAAJ,CAA0B,mBAA1B,CAAN;MACP,CAHD,MAGO,IAAI2B,SAAS,CAACD,MAAV,CAAiBrB,OAAjB,CAAJ,EAA+B;QAClC;QACA,IAAIiB,UAAU,CAACG,MAAX,KAAsB,CAA1B,EAA6B;UACzBL,WAAW,CAACI,eAAZ,GAA8B,CAAC,MAAMpB,UAAU,CAAC+B,kBAAX,CAA8B5B,UAA9B,CAAP,EAAkD6B,SAAhF;QACH;MACJ,CALM,MAKA;QACH,MAAM,IAAIpC,qBAAJ,CAA0B,mBAA1B,CAAN;MACH;IACJ;EACJ,CApBD,MAoBO;IACH;IACAoB,WAAW,CAACG,QAAZ,GAAuBlB,OAAvB;IACAe,WAAW,CAACI,eAAZ,GAA8B,CAAC,MAAMpB,UAAU,CAAC+B,kBAAX,CAA8B5B,UAA9B,CAAP,EAAkD6B,SAAhF;EACH;;EAED,OAAOhB,WAAP;AACH","names":["Transaction","fetch","toUint8Array","nacl","FetchTransactionError","Error","constructor","fetchTransaction","connection","account","link","commitment","response","String","method","mode","cache","credentials","headers","Accept","body","JSON","stringify","json","transaction","from","signatures","feePayer","recentBlockhash","length","equals","publicKey","message","serializeMessage","signature","sign","detached","verify","toBuffer","getRecentBlockhash","blockhash"],"sources":["/Users/khairulamirinrohmat/nft-access/bedrock-nft-access/node_modules/@solana/pay/src/fetchTransaction.ts"],"sourcesContent":["import { Commitment, Connection, PublicKey, Transaction } from '@solana/web3.js';\nimport fetch from 'cross-fetch';\nimport { toUint8Array } from 'js-base64';\nimport nacl from 'tweetnacl';\n\n/**\n * Thrown when a transaction response can't be fetched.\n */\nexport class FetchTransactionError extends Error {\n    name = 'FetchTransactionError';\n}\n\n/**\n * Fetch a transaction from a Solana Pay transaction request link.\n *\n * @param connection - A connection to the cluster.\n * @param account - Account that may sign the transaction.\n * @param link - `link` in the [Solana Pay spec](https://github.com/solana-labs/solana-pay/blob/master/SPEC.md#link).\n * @param options - Options for `getRecentBlockhash`.\n *\n * @throws {FetchTransactionError}\n */\nexport async function fetchTransaction(\n    connection: Connection,\n    account: PublicKey,\n    link: string | URL,\n    { commitment }: { commitment?: Commitment } = {}\n): Promise<Transaction> {\n    const response = await fetch(String(link), {\n        method: 'POST',\n        mode: 'cors',\n        cache: 'no-cache',\n        credentials: 'omit',\n        headers: {\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ account }),\n    });\n\n    const json = await response.json();\n    if (!json?.transaction) throw new FetchTransactionError('missing transaction');\n    if (typeof json.transaction !== 'string') throw new FetchTransactionError('invalid transaction');\n\n    const transaction = Transaction.from(toUint8Array(json.transaction));\n    const { signatures, feePayer, recentBlockhash } = transaction;\n\n    if (signatures.length) {\n        if (!feePayer) throw new FetchTransactionError('missing fee payer');\n        if (!feePayer.equals(signatures[0].publicKey)) throw new FetchTransactionError('invalid fee payer');\n        if (!recentBlockhash) throw new FetchTransactionError('missing recent blockhash');\n\n        // A valid signature for everything except `account` must be provided.\n        const message = transaction.serializeMessage();\n        for (const { signature, publicKey } of signatures) {\n            if (signature) {\n                if (!nacl.sign.detached.verify(message, signature, publicKey.toBuffer()))\n                    throw new FetchTransactionError('invalid signature');\n            } else if (publicKey.equals(account)) {\n                // If the only signature expected is for `account`, ignore the recent blockhash in the transaction.\n                if (signatures.length === 1) {\n                    transaction.recentBlockhash = (await connection.getRecentBlockhash(commitment)).blockhash;\n                }\n            } else {\n                throw new FetchTransactionError('missing signature');\n            }\n        }\n    } else {\n        // Ignore the fee payer and recent blockhash in the transaction and initialize them.\n        transaction.feePayer = account;\n        transaction.recentBlockhash = (await connection.getRecentBlockhash(commitment)).blockhash;\n    }\n\n    return transaction;\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { sendAndConfirmTransaction, Transaction } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from './../constants.mjs';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidMintError, TokenInvalidOwnerError } from './../errors.mjs';\nimport { createAssociatedTokenAccountInstruction } from './../instructions/index.mjs';\nimport { getAccount, getAssociatedTokenAddress } from './../state/index.mjs';\n/**\n * Retrieve the associated token account, or create it if it doesn't exist\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint associated with the account to set or verify\n * @param owner                    Owner of the account to set or verify\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param commitment               Desired level of commitment for querying the state\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the new associated token account\n */\n\nexport async function getOrCreateAssociatedTokenAccount(connection, payer, mint, owner) {\n  let allowOwnerOffCurve = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let commitment = arguments.length > 5 ? arguments[5] : undefined;\n  let confirmOptions = arguments.length > 6 ? arguments[6] : undefined;\n  let programId = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : TOKEN_PROGRAM_ID;\n  let associatedTokenProgramId = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : ASSOCIATED_TOKEN_PROGRAM_ID;\n  const associatedToken = await getAssociatedTokenAddress(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId); // This is the optimal logic, considering TX fee, client-side computation, RPC roundtrips and guaranteed idempotent.\n  // Sadly we can't do this atomically.\n\n  let account;\n\n  try {\n    account = await getAccount(connection, associatedToken, commitment, programId);\n  } catch (error) {\n    // TokenAccountNotFoundError can be possible if the associated address has already received some lamports,\n    // becoming a system account. Assuming program derived addressing is safe, this is the only case for the\n    // TokenInvalidAccountOwnerError in this code path.\n    if (error instanceof TokenAccountNotFoundError || error instanceof TokenInvalidAccountOwnerError) {\n      // As this isn't atomic, it's possible others can create associated accounts meanwhile.\n      try {\n        const transaction = new Transaction().add(createAssociatedTokenAccountInstruction(payer.publicKey, associatedToken, owner, mint, programId, associatedTokenProgramId));\n        await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n      } catch (error) {// Ignore all errors; for now there is no API-compatible way to selectively ignore the expected\n        // instruction error if the associated account exists already.\n      } // Now this should always succeed\n\n\n      account = await getAccount(connection, associatedToken, commitment, programId);\n    } else {\n      throw error;\n    }\n  }\n\n  if (!account.mint.equals(mint)) throw new TokenInvalidMintError();\n  if (!account.owner.equals(owner)) throw new TokenInvalidOwnerError();\n  return account;\n}","map":{"version":3,"mappings":"AAAA,SAKIA,yBALJ,EAOIC,WAPJ,QAQO,iBARP;AASA,SAASC,2BAAT,EAAsCC,gBAAtC,QAA8D,oBAA9D;AACA,SACIC,yBADJ,EAEIC,6BAFJ,EAGIC,qBAHJ,EAIIC,sBAJJ,QAKO,iBALP;AAMA,SAASC,uCAAT,QAAwD,6BAAxD;AACA,SAAkBC,UAAlB,EAA8BC,yBAA9B,QAA+D,sBAA/D;AAEA;;;;;;;;;;;;;;;;AAeA,OAAO,eAAeC,iCAAf,CACHC,UADG,EAEHC,KAFG,EAGHC,IAHG,EAIHC,KAJG,EASmD;EAAA,IAJtDC,kBAIsD,uEAJjC,KAIiC;EAAA,IAHtDC,UAGsD;EAAA,IAFtDC,cAEsD;EAAA,IADtDC,SACsD,uEAD1ChB,gBAC0C;EAAA,IAAtDiB,wBAAsD,uEAA3BlB,2BAA2B;EAEtD,MAAMmB,eAAe,GAAG,MAAMX,yBAAyB,CACnDI,IADmD,EAEnDC,KAFmD,EAGnDC,kBAHmD,EAInDG,SAJmD,EAKnDC,wBALmD,CAAvD,CAFsD,CAUtD;EACA;;EACA,IAAIE,OAAJ;;EACA,IAAI;IACAA,OAAO,GAAG,MAAMb,UAAU,CAACG,UAAD,EAAaS,eAAb,EAA8BJ,UAA9B,EAA0CE,SAA1C,CAA1B;EACH,CAFD,CAEE,OAAOI,KAAP,EAAuB;IACrB;IACA;IACA;IACA,IAAIA,KAAK,YAAYnB,yBAAjB,IAA8CmB,KAAK,YAAYlB,6BAAnE,EAAkG;MAC9F;MACA,IAAI;QACA,MAAMmB,WAAW,GAAG,IAAIvB,WAAJ,GAAkBwB,GAAlB,CAChBjB,uCAAuC,CACnCK,KAAK,CAACa,SAD6B,EAEnCL,eAFmC,EAGnCN,KAHmC,EAInCD,IAJmC,EAKnCK,SALmC,EAMnCC,wBANmC,CADvB,CAApB;QAWA,MAAMpB,yBAAyB,CAACY,UAAD,EAAaY,WAAb,EAA0B,CAACX,KAAD,CAA1B,EAAmCK,cAAnC,CAA/B;MACH,CAbD,CAaE,OAAOK,KAAP,EAAuB,CACrB;QACA;MACH,CAlB6F,CAoB9F;;;MACAD,OAAO,GAAG,MAAMb,UAAU,CAACG,UAAD,EAAaS,eAAb,EAA8BJ,UAA9B,EAA0CE,SAA1C,CAA1B;IACH,CAtBD,MAsBO;MACH,MAAMI,KAAN;IACH;EACJ;;EAED,IAAI,CAACD,OAAO,CAACR,IAAR,CAAaa,MAAb,CAAoBb,IAApB,CAAL,EAAgC,MAAM,IAAIR,qBAAJ,EAAN;EAChC,IAAI,CAACgB,OAAO,CAACP,KAAR,CAAcY,MAAd,CAAqBZ,KAArB,CAAL,EAAkC,MAAM,IAAIR,sBAAJ,EAAN;EAElC,OAAOe,OAAP;AACH","names":["sendAndConfirmTransaction","Transaction","ASSOCIATED_TOKEN_PROGRAM_ID","TOKEN_PROGRAM_ID","TokenAccountNotFoundError","TokenInvalidAccountOwnerError","TokenInvalidMintError","TokenInvalidOwnerError","createAssociatedTokenAccountInstruction","getAccount","getAssociatedTokenAddress","getOrCreateAssociatedTokenAccount","connection","payer","mint","owner","allowOwnerOffCurve","commitment","confirmOptions","programId","associatedTokenProgramId","associatedToken","account","error","transaction","add","publicKey","equals"],"sources":["/Users/khairulamirinrohmat/nft-access/bedrock-nft-access/node_modules/@solana/spl-token/src/actions/getOrCreateAssociatedTokenAccount.ts"],"sourcesContent":["import {\n    Commitment,\n    ConfirmOptions,\n    Connection,\n    PublicKey,\n    sendAndConfirmTransaction,\n    Signer,\n    Transaction,\n} from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants';\nimport {\n    TokenAccountNotFoundError,\n    TokenInvalidAccountOwnerError,\n    TokenInvalidMintError,\n    TokenInvalidOwnerError,\n} from '../errors';\nimport { createAssociatedTokenAccountInstruction } from '../instructions/index';\nimport { Account, getAccount, getAssociatedTokenAddress } from '../state/index';\n\n/**\n * Retrieve the associated token account, or create it if it doesn't exist\n *\n * @param connection               Connection to use\n * @param payer                    Payer of the transaction and initialization fees\n * @param mint                     Mint associated with the account to set or verify\n * @param owner                    Owner of the account to set or verify\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param commitment               Desired level of commitment for querying the state\n * @param confirmOptions           Options for confirming the transaction\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the new associated token account\n */\nexport async function getOrCreateAssociatedTokenAccount(\n    connection: Connection,\n    payer: Signer,\n    mint: PublicKey,\n    owner: PublicKey,\n    allowOwnerOffCurve = false,\n    commitment?: Commitment,\n    confirmOptions?: ConfirmOptions,\n    programId = TOKEN_PROGRAM_ID,\n    associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID\n): Promise<Account> {\n    const associatedToken = await getAssociatedTokenAddress(\n        mint,\n        owner,\n        allowOwnerOffCurve,\n        programId,\n        associatedTokenProgramId\n    );\n\n    // This is the optimal logic, considering TX fee, client-side computation, RPC roundtrips and guaranteed idempotent.\n    // Sadly we can't do this atomically.\n    let account: Account;\n    try {\n        account = await getAccount(connection, associatedToken, commitment, programId);\n    } catch (error: unknown) {\n        // TokenAccountNotFoundError can be possible if the associated address has already received some lamports,\n        // becoming a system account. Assuming program derived addressing is safe, this is the only case for the\n        // TokenInvalidAccountOwnerError in this code path.\n        if (error instanceof TokenAccountNotFoundError || error instanceof TokenInvalidAccountOwnerError) {\n            // As this isn't atomic, it's possible others can create associated accounts meanwhile.\n            try {\n                const transaction = new Transaction().add(\n                    createAssociatedTokenAccountInstruction(\n                        payer.publicKey,\n                        associatedToken,\n                        owner,\n                        mint,\n                        programId,\n                        associatedTokenProgramId\n                    )\n                );\n\n                await sendAndConfirmTransaction(connection, transaction, [payer], confirmOptions);\n            } catch (error: unknown) {\n                // Ignore all errors; for now there is no API-compatible way to selectively ignore the expected\n                // instruction error if the associated account exists already.\n            }\n\n            // Now this should always succeed\n            account = await getAccount(connection, associatedToken, commitment, programId);\n        } else {\n            throw error;\n        }\n    }\n\n    if (!account.mint.equals(mint)) throw new TokenInvalidMintError();\n    if (!account.owner.equals(owner)) throw new TokenInvalidOwnerError();\n\n    return account;\n}\n"]},"metadata":{},"sourceType":"module"}